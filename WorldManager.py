'''The WorldManager is the object that interacts with all the world objects and runs the simulation'''
import os
import random
from time import sleep

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt


class WorldManager:
    def __init__(self, map, reporters, point_calc_func, dist_radius=500, time_range=5, neighbors_limit=8):
        '''
        :param map: a Map object of the world
        :param reporters: list of Reporter objects that provide the reports
        :param point_calc_func: The function used to calculate a points value based on it's neighbors
        :param dist_radius: radius used to calculate Datapoint's neighbors
        :param time_range: time range used to calculate Datapoint's neighbors
        :param neighbors_limit: Max amount of neighbors a Datapoint can have
        '''
        self.map = map
        self.reporters = reporters
        self.point_calc = point_calc_func
        self.dist_radius = dist_radius
        self.time_range = time_range
        self.neighbors_limit = neighbors_limit
        self.T = 0  # Current time

        # Real history is a df where every row represents a day and every coloumn a point
        self.history = pd.DataFrame([], columns=[point.id for point in map.data_points])

        # reports history saves all the reports generated
        self.reports = pd.DataFrame([], columns=['T', 'POINT_ID', 'REPORTER_ID', 'REPORTED_S', 'Veracity', 'TRUE_S'])

    def __repr__(self):
        return f"WorldManager T = {self.T}"

    def tick(self, days=1, with_show=False, with_show_values=False):
        '''
        Time moves forward - values for Datapoints change and reports are generated by reporters.
        :param days: How many days would pass
        :with_show: Show the map as it ticks
        :return:
        '''
        if with_show:
            from matplotlib import pyplot as plt
            plt.ion()

        for i in range(days):
            self.apply_calculations()
            self.update_history()
            self.generate_reports()

            if with_show:
                self.get_plot(with_show_values).draw()
                plt.title(f"T = {self.T}")
                plt.clf()
                sleep(0.6)

    def apply_calculations(self):
        ''' Applies the infection calculation to every point'''
        for point in self.map.data_points:
            new_s = self.point_calc(point, self.map.neighbors[point.id])
            point.update_s(new_s)
        self.update_history()

    def generate_reports(self):
        '''Generates reports from the reporters and updates self.reports'''
        new_reports = []
        for reporter in self.reporters:
            new_reports += reporter.report_points(self.T)
        df = pd.DataFrame(new_reports, columns=['T', 'POINT_ID', 'REPORTER_ID', 'REPORTED_S', 'Veracity', 'TRUE_S'])
        self.reports = self.reports.append(df)

    def update_history(self):
        '''Writes the new point values to the history'''
        self.T += 1
        new_day = pd.DataFrame(np.array([[point.s] for point in self.map.data_points]).transpose(),
                               columns=[point.id for point in self.map.data_points], index=[self.T])
        self.history = self.history.append(new_day)

    def intervention(self, effect_dist, points):
        '''
        :param effect_dist: a distribution of values to draw the intervention effect from
        :param points: Datapoints on which the intervention works
        :return:
        '''
        for point in points:
            current_s = point.s
            factor = effect_dist()
            new_s = current_s + factor
            point.update_s(new_s, intervention=True)
        self.update_history()

    def random_intervention(self, ratio=0.1, effect_dist=lambda: random.gauss(0.6, 0.3)):
        '''applies intervention to random points in the map. Can be used when starting the map for example'''
        n = int(len(self.map.data_points) * ratio)
        points = random.sample(self.map.data_points, n)
        self.intervention(effect_dist, points)

    def save_state(self, output_path):
        '''
        :param output_path: File to save the report at. If "none" it would just print
        :return:
        '''
        output = os.path.join(output_path, "Results")
        os.mkdir(output)
        self.reports.to_csv("reports.csv")
        self.history.to_csv("values history.csv")

    def get_plot(self, with_values=False):
        '''
        Plots cu
        :param with_values: If true, annotates the value next to each point
        :return: returns a plot object
        '''
        values = self.history.iloc[-1].to_numpy()
        x_cors = np.array([point.x for point in self.map.data_points])
        y_cors = np.array([point.y for point in self.map.data_points])
        plt.scatter(x_cors, y_cors, c=values, cmap='Reds', s=350)
        return plt

    def show(self, with_values=False):
        '''Plots the current state of the DataPoints'''
        self.get_plot(with_values).show()
