'''The WorldManager is the object that interacts with all the world objects and runs the simulation'''
import os
import random
from collections import defaultdict
from time import sleep

import numpy as np
import pandas as pd
import scipy
from matplotlib import pyplot as plt
from scipy.stats import gamma

import World_Objects
from Generic_Calcs import fit_average_posterior, plot_dist, get_range_from_dist


class WorldManager:
    def __init__(self, map: World_Objects.Map, reporters: [World_Objects.Reporter], point_calc_func, weight_func,
                 dist_type: scipy.stats.rv_continuous, prior_params: tuple, prior_decay_func, loss_func,prediction_unit_func, priors={},
                 dist_radius='inf',
                 time_range=5,
                 neighbors_limit=8, clean_area_chance=0.1, prior_decay_factor=1, reports=None,prediction_units:dict = {}):
        '''
        :param map: a Map object of the world
        :param reporters: list of Reporter objects that  provide the reports
        :param point_calc_func: The function used to calculate a points value based on it's neighbors
        :param dist_type: the type of distribution for each point (e.g gamma)
        :param priors: a list of prior params for each point
        :param dist_radius: radius used to calculate Datapoint's neighbors
        :param time_range: time range used to calculate Datapoint's neighbors
        :param neighbors_limit: Max amount of neighbors a Datapoint can have
        :param prior_decay_factor: How much a point's prior will revert back to hyper-prior every day if no report
        :param prior_decay_func: Function that takes paramters of a distribution and returns a new distribution with less veracity (e.g. makes SD larger)
        '''
        self.loss_func = loss_func
        self.map = map
        self.prediction_units = prediction_units
        self.reporters = reporters
        self.point_calc = point_calc_func
        self.dist_radius = dist_radius
        self.time_range = time_range
        self.neighbors_limit = neighbors_limit
        self.T = 0  # Current time
        self.dist_type = dist_type
        self.hyper_prior = prior_params  # in use for clean area only currently
        self.prior_decay = prior_decay_factor  # not in use
        self.points_dic = {}
        self.weight_func = weight_func
        self.prior_decay_func = prior_decay_func
        self.clean_days = defaultdict(lambda: [])
        self.prior_history = []
        self.prediction_unit_func = prediction_unit_func

        assert 0 <= clean_area_chance <= 1
        self.clean_area_chance = clean_area_chance

        # assign prior params to any point we know nothing about
        self.priors = priors
        self.last_report_times = defaultdict(lambda: 0)  # When a point got a report (values of T)
        for p in map.data_points:
            self.points_dic[p.id] = p
            if p.id not in self.priors:
                self.priors[p.id] = prior_params

        # Real history is a df where every row represents a day and every coloumn a point
        self.history = pd.DataFrame([], columns=[point.id for point in map.data_points])

        # reports history saves all the reports generated
        if reports is None:
            self.reports = pd.DataFrame([],
                                        columns=['T', 'POINT_ID', 'REPORTER_ID', 'REPORTED_S', 'Veracity', 'TRUE_S'])
        else:
            self.reports = reports

    def __repr__(self):
        return f"WorldManager T = {self.T}"

    def tick(self, days=1, with_show=False, with_show_values=False):
        '''
        Time moves forward - values for Datapoints change and reports are generated by reporters.
        :param days: How many days would pass
        :with_show: Show the map as it ticks
        :return:
        '''
        if with_show:
            plt.ion()

        for i in range(days):
            # True calculations
            self.T += 1
            self.apply_calculations()
            self.update_history()

            self.apply_prior_decays()

            # predict for all points:
            new_priors = self.priors.copy()
            for point in self.map.data_points:
                new_priors[point.id] = self.predict_point_reports(point.id)
            self.priors = new_priors

            # clean areas
            for area in self.map.areas:
                should_clean = random.uniform(0, 1) <= self.clean_area_chance
                if should_clean:
                    self.clean_days[self.T].append(area)
                    self.clean_area(area)

            self.generate_reports()
            self.apply_today_reports()
            self.prior_history.append(self.priors)

            if with_show:
                self.get_plot(with_show_values).draw()
                plt.title(f"T = {self.T}")
                plt.clf()
                sleep(0.6)
                print(f' Current average loss = {self.current_average_loss()}')

    def apply_calculations(self):
        ''' Applies the infection calculation to every point'''
        for point in self.map.data_points:
            new_s = self.point_calc(point, self.map.neighbors[point.id])
            point.update_s(new_s)

    def generate_reports(self):
        '''Generates reports from the reporters and updates self.reports'''
        new_reports = []
        for reporter in self.reporters:
            new_reports += reporter.report_points(self.T)
        df = pd.DataFrame(new_reports, columns=['T', 'POINT_ID', 'REPORTER_ID', 'REPORTED_S', 'Veracity', 'TRUE_S'])
        self.reports = self.reports.append(df)

    def predict_point_report(self, target_id: str, s: float, v: float, n_samples=10000):
        '''
        Updates point's prior based on a report
        :param target: Point ID for target
        :param s: report's s
        :param v:  report's veracity
        :return: points new prior params, generated by scipy
        '''

        loc = 0.99 if s == 1 else s  # to avoid values above 1
        report_dist_params = (1, loc, 0.0001)
        posterior = fit_average_posterior(self.priors[target_id], report_dist_params, self.dist_type, gamma,
                                          weights=((1 - v), v),
                                          result_dist_type=self.dist_type, n_samples=n_samples)
        if posterior[1] >= 1:
            posterior = (posterior[0], 0.98, posterior[2])
        return posterior

    def predict_point_reports(self, point_id, only_reports=False, k=1000, show_as_range=False):
        '''
        Predicts a point's distribution based on its neighbors. Taking into account time decay because looking only at reports
        :param only_reports: If true, uses only reported data to calculate. Otherwise uses current priors for all neighbors
        :param show_as_range: return the result as a range of values
        :param point_id:
        :param k:
        :return:
        '''
        target = self.points_dic[point_id]
        neighbors = self.map.neighbors[point_id] + [target]  # point is neighbor to itself

        if only_reports:
            weights = np.array(
                [self.weight_func(target.calc_distance(p), (self.T - self.last_report_times[p.id])) for p in neighbors])
        else:
            weights = np.array(
                [self.weight_func(target.calc_distance(p), 1) for p in neighbors])
        weights_sum = sum(weights)
        neighbor_predictions = np.column_stack([self.dist_type.rvs(*self.priors[p.id], size=k) for p in neighbors])
        weighted_predictions = (neighbor_predictions @ weights) / weights_sum
        new_dist = self.dist_type.fit(weighted_predictions)

        if show_as_range:
            return get_range_from_dist(self.dist_type, new_dist)

        return new_dist

    def apply_today_reports(self):
        '''
        Updates the posteriors of point's that got reported today
        :return:
        '''
        if len(self.reports) > 0:
            today_reports = self.reports[self.reports['T'] == max(self.reports['T'])]
            if len(today_reports) > 0:
                today_reports.apply(lambda row: self.update_point_prior_by_row(row), axis=1)

    def update_point_prior_by_row(self, row):
        '''
        Takes a row from the reports data frame and updates the points prior
        :param row:
        :return:
        '''
        s = row['REPORTED_S']
        v = row['Veracity']
        T = row['T']
        point_id = row['POINT_ID']
        posterior = self.predict_point_report(point_id, s, v)
        self.priors[point_id] = posterior
        self.last_report_times[point_id] = T

    def apply_prior_decays(self):
        for p in self.priors:
            self.priors[p] = self.prior_decay_func(self.priors[p])

    def decay_unreported_points_to_hp(self):
        '''
        For every points we didn't get a report, we make the points prior to look more like the hyper-prior
        ***currently not in use
        '''
        t = self.T

        # hp_fit_for_assert = self.dist_type.fit(self.dist_type.rvs(**self.hyper_prior, size=50000))
        # assert (abs(hp_fit_for_assert[0] - self.hyper_prior["a"]) < 0.2 and abs(hp_fit_for_assert[2] - self.hyper_prior[
        #     "scale"]) < 0.2), "Maybe the code works with scipy.stats.gamma distribution but you provided something else"

        for p in self.map.data_points:
            point_id = p.id
            if self.last_report_times[point_id] < t:
                posterior = fit_average_posterior(self.hyper_prior, self.priors[point_id], self.dist_type,
                                                  self.dist_type,
                                                  weights=(self.prior_decay, 1 - self.prior_decay),
                                                  result_dist_type=self.dist_type)
                self.priors[point_id] = posterior

    def update_history(self):
        '''Writes the new point values to the history'''
        new_day = pd.DataFrame(np.array([[point.s] for point in self.map.data_points]).transpose(),
                               columns=[point.id for point in self.map.data_points], index=[self.T])
        self.history = self.history.append(new_day)

    def intervention(self, effect_dist, points):
        '''
        :param effect_dist: a distribution of values to draw the intervention effect from
        :param points: Datapoints on which the intervention works
        :return:
        '''
        for point in points:
            current_s = point.s
            factor = effect_dist()
            new_s = current_s + factor
            point.update_s(new_s, intervention=True)
        self.update_history()

    def random_positive_intervention(self, ratio=0.1, effect_dist=lambda: random.gauss(0.6, 0.3)):
        '''applies intervention to random points in the map. Can be used when starting the map for example'''
        n = int(len(self.map.data_points) * ratio)
        points = random.sample(self.map.data_points, n)
        self.intervention(effect_dist, points)

    def clean_area(self, area_id: str):
        '''
        Returns all of the area's points to their initial s stage (samples from hyper_prior)
        :param area_id:
        :return:
        '''
        points = self.map.areas[area_id][0]
        for point in points:
            point.update_s(self.dist_type(*self.hyper_prior).rvs(), intervention=True)
            self.priors[point.id] = self.hyper_prior

    def save_state(self, output_path):
        '''
        :param output_path: File to save the report at. If "none" it would just print
        :return:
        '''
        output = os.path.join(output_path, "Results")
        os.mkdir(output)
        self.reports.to_csv("reports.csv")
        self.history.to_csv("values history.csv")

    def get_plot(self, with_values=True):
        '''
        Plots current map state
        :param with_values: If true, annotates the value next to each point
        :return: returns a plot object
        '''
        values = self.history.iloc[-1].to_numpy()
        x_cors = np.array([point.x for point in self.map.data_points])
        y_cors = np.array([point.y for point in self.map.data_points])
        fig, ax = plt.subplots()
        ax.scatter(x_cors, y_cors, c=values, cmap='Reds', s=350)
        for point in self.map.data_points:
            txt = f'{point.id} s={round(point.s, 2)}' if with_values else point.id
            ax.annotate(txt, (point.x, point.y))
        return plt

    def show_real(self, with_values=False):
        '''Plots the current state of the DataPoints'''
        self.get_plot(with_values).show()

    def show_dist(self, point_id: str):
        dist_params = self.priors[point_id]
        dist_type = self.dist_type
        plot_dist(dist_type, dist_params, annotate_value=self.points_dic[point_id].s)

    def show_range(self, point_id: str, percentiles=(30, 70)):
        dist_params = self.priors[point_id]
        dist_type = self.dist_type
        return get_range_from_dist(dist_type, dist_params, percentiles)

    def legacy_extract_data_for_train(self, n_days: int, points_per_day=4, all_points=False):  # not sure I use this
        '''
        :return:
        '''
        data = []
        for i in range(n_days):
            points_to_target = self.map.data_points if all_points else random.sample(self.map.data_points,
                                                                                     points_per_day)
            for point in points_to_target:
                y = point.s
                neighbors = self.map.neighbors[point.id] + [point]  # point is neighbor to itself
                X = tuple([(self.priors[neighbor.id], neighbor.calc_distance(point),
                            self.T - self.last_report_times[neighbor.id]) for neighbor in neighbors])
                data.append((X, y))
        return data

    def point_loss(self, point_id: str) -> float:
        '''
        Returns current point loss in respect to its prior and real s
        :param point_id:
        :return:
        '''
        prior = self.priors[point_id]
        s = self.points_dic[point_id].s
        return self.loss_func(self.dist_type, prior, s)

    def current_average_loss(self):
        res = 0
        n = len(self.map.data_points)
        for point in self.map.data_points:
            res += self.point_loss(point.id) / n
        return res

    def add_prediction_unit(self,data_points,unit_id,unit_func = None):
        if unit_func is None:
            unit_func = self.prediction_unit_func
        new_unit = World_Objects.PredictionUnit(data_points,unit_func,unit_id)
        self.prediction_units[unit_id] = new_unit

    def get_prediction_for_PD(self,unit_id):
        unit = self.prediction_units[unit_id]
        data_points = unit.data_points
        func = unit.agg_func
        params = [self.priors[point.id] for point in data_points]
        return func(params)



class WorldTester(WorldManager):
    def __init__(self, source_reports, clean_days,start_day: int,priors_at_start_day, *params):
        super().__init__(*params)
        self.source_reports = source_reports
        self.clean_days = clean_days
        self.total_loss = 0
        self.start_day = start_day
        self.n_samples = len(source_reports['T'] > start_day)
        self.priors = priors_at_start_day

    def report_loss(self, row):
        label = row['REPORTED_S']
        v = row['Veracity']
        point_id = row['POINT_ID']

        loss = self.loss_func(self.dist_type, self.priors[point_id], label) * (v ** 2)
        return loss

    def day_loss(self):
        '''
        Calculates loss for all the reports given today in the tester and the original
        :return:
        '''
        day = self.source_reports[self.source_reports['T'] == self.T][['POINT_ID', 'REPORTED_S', 'Veracity']]
        day_loss = sum(self.report_loss(day))
        return day_loss

    def test_tick(self, ignore = False):
        self.T += 1
        self.apply_prior_decays()

        # predict for all points:
        new_priors = self.priors.copy()
        for point in self.map.data_points:
            new_priors[point.id] = self.predict_point_reports(point.id)
        self.priors = new_priors

        # clean areas
        if self.T in self.clean_days:
            for area in self.clean_days[self.T]:
                self.clean_area(area)
        self.generate_reports()
        self.apply_today_reports()
        if ignore: return
        day_loss = self.day_loss()
        self.total_loss+=day_loss

    def calculate_world_loss(self):
        n_days = max(self.source_reports['T'])
        for i in range(self.ignore_days):
            self.test_tick(ignore = True)
        for i in range(n_days-self.ignore_days):
            self.test_tick()
        return self.total_loss/self.n_samples



