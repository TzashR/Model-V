'''The WorldManager is the object that interacts with all the world objects and runs the simulation'''
import os
import random
from time import sleep

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from scipy.stats import uniform

from Generic_Calcs import fit_average_posterior, plot_dist


class WorldManager:
    def __init__(self, map, reporters, point_calc_func, dist_type, prior_params, priors={}, dist_radius='inf',
                 time_range=5,
                 neighbors_limit=8, prior_decay=0.05):
        '''
        :param map: a Map object of the world
        :param reporters: list of Reporter objects that provide the reports
        :param point_calc_func: The function used to calculate a points value based on it's neighbors
        :param dist_type: the type of distribution for each point (e.g gamma)
        :param priors: a list of prior params for each point
        :param dist_radius: radius used to calculate Datapoint's neighbors
        :param time_range: time range used to calculate Datapoint's neighbors
        :param neighbors_limit: Max amount of neighbors a Datapoint can have
        :param prior_decay: How much a point's prior will revert back to hyper-prior every day if no report
        '''
        self.map = map
        self.reporters = reporters
        self.point_calc = point_calc_func
        self.dist_radius = dist_radius
        self.time_range = time_range
        self.neighbors_limit = neighbors_limit
        self.T = 0  # Current time
        self.dist_type = dist_type
        self.hyper_prior = prior_params
        self.prior_decay = prior_decay

        # assign prior params to any point we know nothing about
        self.priors = priors
        self.last_report_times = {} # When a point got a report (values of T)
        for p in map.data_points:
            if p.id not in self.priors:
                self.priors[p.id] = prior_params
                self.last_report_times[p.id] = 0


        # Real history is a df where every row represents a day and every coloumn a point
        self.history = pd.DataFrame([], columns=[point.id for point in map.data_points])

        # reports history saves all the reports generated
        self.reports = pd.DataFrame([], columns=['T', 'POINT_ID', 'REPORTER_ID', 'REPORTED_S', 'Veracity', 'TRUE_S'])

    def __repr__(self):
        return f"WorldManager T = {self.T}"

    def tick(self, days=1, with_show=False, with_show_values=False):
        '''
        Time moves forward - values for Datapoints change and reports are generated by reporters.
        :param days: How many days would pass
        :with_show: Show the map as it ticks
        :return:
        '''
        if with_show:
            plt.ion()

        for i in range(days):
            self.T +=1
            self.apply_calculations()
            self.update_history()
            self.generate_reports()
            self.apply_today_reports()
            self.decay_unreported_points()

            if with_show:
                self.get_plot(with_show_values).draw()
                plt.title(f"T = {self.T}")
                plt.clf()
                sleep(0.6)

    def apply_calculations(self):
        ''' Applies the infection calculation to every point'''
        for point in self.map.data_points:
            new_s = self.point_calc(point, self.map.neighbors[point.id])
            point.update_s(new_s)

    def generate_reports(self):
        '''Generates reports from the reporters and updates self.reports'''
        new_reports = []
        for reporter in self.reporters:
            new_reports += reporter.report_points(self.T)
        df = pd.DataFrame(new_reports, columns=['T', 'POINT_ID', 'REPORTER_ID', 'REPORTED_S', 'Veracity', 'TRUE_S'])
        self.reports = self.reports.append(df)


    def predict_point_report(self, target_id: str, s: float, v:float, n_samples=10000):
        '''

        :param target: Point ID for target
        :param s: report's s
        :param v:  report's veracity
        :return: points new prior params, generated by scipy
        '''

        loc = 0.99 if s == 1 else s #to avoid values above 1

        report_dist_params = {'loc': loc, "scale": 0.0001}

        posterior = fit_average_posterior(self.priors[target_id], report_dist_params, self.dist_type, uniform,
                                          weights=((1 - v), v),
                                          result_dist_type=self.dist_type, n_samples=n_samples)
        return posterior

    def apply_today_reports(self):
        '''
        Updates the posteriors of point's that got reported today
        :return:
        '''
        if len(self.reports)>0:
            today_reports = self.reports[self.reports['T'] == max(self.reports['T'])]
            if len(today_reports) > 0:
                today_reports.apply(lambda row: self.update_point_prior_by_row(row), axis = 1)


    def update_point_prior_by_row(self, row):
        '''
        Takes a row from the reports data frame and updates the points prior
        :param row:
        :return:
        '''
        s = row['REPORTED_S']
        v = row['Veracity']
        T = row['T']
        point_id = row['POINT_ID']
        posterior = self.predict_point_report(point_id,s,v)
        self.priors[point_id]["a"] = posterior[0]
        self.priors[point_id]["scale"] = posterior[1]
        self.priors[point_id]["scale"] = posterior[2]
        self.last_report_times[point_id] = T




    def decay_unreported_points(self):
        '''
        For every points we didn't get a report, we make the points prior to look more like the hyper-prior
        '''
        t = self.T

        # hp_fit_for_assert = self.dist_type.fit(self.dist_type.rvs(**self.hyper_prior, size=50000))
        # assert (abs(hp_fit_for_assert[0] - self.hyper_prior["a"]) < 0.2 and abs(hp_fit_for_assert[2] - self.hyper_prior[
        #     "scale"]) < 0.2), "Maybe the code works with scipy.stats.gamma distribution but you provided something else"

        for p in self.map.data_points:
            point_id = p.id
            if self.last_report_times[point_id] < t:
                posterior = fit_average_posterior(p.prior, self.hyper_prior, self.dist_type, self.dist_type,
                                                  weights=(self.prior_decay, 1 - self.prior_decay),
                                                  result_dist_type=self.dist_type)
                # The following only works with gamma!!
                self.priors[point_id]["a"] = posterior[0]
                self.priors[point_id]["loc"] = posterior[1]
                self.priors[point_id]["scale"] = posterior[2]

    def update_history(self):
        '''Writes the new point values to the history'''
        new_day = pd.DataFrame(np.array([[point.s] for point in self.map.data_points]).transpose(),
                               columns=[point.id for point in self.map.data_points], index=[self.T])
        self.history = self.history.append(new_day)

    def intervention(self, effect_dist, points):
        '''
        :param effect_dist: a distribution of values to draw the intervention effect from
        :param points: Datapoints on which the intervention works
        :return:
        '''
        for point in points:
            current_s = point.s
            factor = effect_dist()
            new_s = current_s + factor
            point.update_s(new_s, intervention=True)
        self.update_history()

    def random_intervention(self, ratio=0.1, effect_dist=lambda: random.gauss(0.6, 0.3)):
        '''applies intervention to random points in the map. Can be used when starting the map for example'''
        n = int(len(self.map.data_points) * ratio)
        points = random.sample(self.map.data_points, n)
        self.intervention(effect_dist, points)

    def save_state(self, output_path):
        '''
        :param output_path: File to save the report at. If "none" it would just print
        :return:
        '''
        output = os.path.join(output_path, "Results")
        os.mkdir(output)
        self.reports.to_csv("reports.csv")
        self.history.to_csv("values history.csv")

    def get_plot(self, with_values=False):
        # TODO add with_values functionality
        '''
        Plots current map state
        :param with_values: If true, annotates the value next to each point
        :return: returns a plot object
        '''
        values = self.history.iloc[-1].to_numpy()
        x_cors = np.array([point.x for point in self.map.data_points])
        y_cors = np.array([point.y for point in self.map.data_points])
        plt.scatter(x_cors, y_cors, c=values, cmap='Reds', s=350)
        return plt

    def show_real(self, with_values=False):
        '''Plots the current state of the DataPoints'''
        self.get_plot(with_values).show()

    def show_dist(self, point_id: str):
        dist_params = self.priors[point_id]
        dist_type = self.dist_type
        plot_dist(dist_type,dist_params)