'''The WorldManager is the object that interacts with all the world objects and runs the simulation'''
import random
import pandas as pd
import os

class WorldManager:
    def __init__(self, map, reporters, point_calc_func, dist_radius=500, time_range=5, neighbors_limit=8):
        '''
        :param map: a Map object of the world
        :param reporters: list of Reporter objects that provide the reports
        :param point_calc_func: The function used to calculate a points value based on it's neighbors
        :param dist_radius: radius used to calculate Datapoint's neighbors
        :param time_range: time range used to calculate Datapoint's neighbors
        :param neighbors_limit: Max amount of neighbors a Datapoint can have
        '''
        self.map = map
        self.reporters = reporters
        self.point_calc = point_calc_func
        self.dist_radius = dist_radius
        self.time_range = time_range
        self.neighbors_limit = neighbors_limit
        self.T = 0  # Current time

        # Real history is a df where every row represents a day and every coloumn a point
        self.history = pd.DataFrame([], columns=[point.id for point in map.data_points])

        # reports history saves all the reports generated
        self.reports = pd.DataFrame([], columns=['T','POINT_ID','REPORTER_ID','REPORTED_S','Veracity','TRUE_S'])

    def tick(self, days=1):
        '''
        Time moves forward - values for Datapoints change and reports are generated by reporters.
        :param days: How many days would pass
        :return:
        '''

        for i in range(days):
            self.apply_calculations()
            self.update_history()
            self.generate_reports()


    def apply_calculations(self):
        ''' Applies the infection calculation to every point'''
        for point in self.map.data_points:
            new_s = self.point_calc(point.id, self.map.neighbors[point.id])
            point.update_s(new_s)
        self.update_history()

    def generate_reports(self):
        '''Generates reports from the reporters and updates self.reports'''
        new_reports = []
        for reporter in self.reporters:
            new_reports+= reporter.report_points(self.T)
        df = pd.DataFrame(new_reports, columns=['T','POINT_ID','REPORTER_ID','REPORTED_S','Veracity','TRUE_S'])
        self.reports = self.reports.append(df)



    def update_history(self):
        '''Writes the new point values to the history and ticks the clock by 1'''
        self.T += 1
        new_day = pd.DataFrame([point.s for point in self.map.data_points],
                               columns=[point.id for point in self.map.data_points], index=[self.T])
        self.history.append(new_day)

    def intervention(self, effect_dist, points):
        '''
        :param effect_dist: a distribution of values to draw the intervention effect from
        :param points: Datapoints on which the intervention works
        :return:
        '''
        for point in points:
            current_s = point.s
            factor = effect_dist()
            new_s = current_s + factor
            point.update_s(new_s, intervention=True)
        self.T += 1

    def random_intervention(self, ratio=0.1, effect_dist=lambda: random.gauss(0.3, 0.6)):
        '''applies intervention to random points in the map. Can be used when starting the map for example'''
        n = int(len(self.map.data_points) * ratio)
        points = random.sample(self.map.data_points, n)
        self.intervention(effect_dist, points)

    def save_state(self, output_path):
        '''
        :param output_path: File to save the report at. If "none" it would just print
        :return:
        '''
        output = os.path.join(output_path,"Results")
        os.mkdir(output)
        self.reports.to_csv("reports.csv")
        self.history.to_csv("values history.csv")



