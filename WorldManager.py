'''The WorldManager is the object that interacts with all the world objects and runs the simulation'''
import os
import random
from collections import defaultdict
from time import sleep

import numpy as np
import pandas as pd
import scipy
from matplotlib import pyplot as plt
from scipy.stats import gamma

import World_Objects
from Generic_Calcs import fit_average_posterior, plot_dist, get_range_from_dist


class WorldManager:
    def __init__(self, map: World_Objects.Map, reporters: [World_Objects.Reporter], point_calc_func, weight_func,
                 dist_type: scipy.stats.rv_continuous, prior_params: tuple, priors={}, dist_radius='inf',
                 time_range=5,
                 neighbors_limit=8, prior_decay=0.1):
        '''
        :param map: a Map object of the world
        :param reporters: list of Reporter objects that  provide the reports
        :param point_calc_func: The function used to calculate a points value based on it's neighbors
        :param dist_type: the type of distribution for each point (e.g gamma)
        :param priors: a list of prior params for each point
        :param dist_radius: radius used to calculate Datapoint's neighbors
        :param time_range: time range used to calculate Datapoint's neighbors
        :param neighbors_limit: Max amount of neighbors a Datapoint can have
        :param prior_decay: How much a point's prior will revert back to hyper-prior every day if no report
        '''
        self.map = map
        self.reporters = reporters
        self.point_calc = point_calc_func
        self.dist_radius = dist_radius
        self.time_range = time_range
        self.neighbors_limit = neighbors_limit
        self.T = 0  # Current time
        self.dist_type = dist_type
        self.hyper_prior = prior_params
        self.prior_decay = prior_decay
        self.points_dic = {}
        self.weight_func = weight_func

        # assign prior params to any point we know nothing about
        self.priors = priors
        self.last_report_times = defaultdict(lambda: 0)  # When a point got a report (values of T)
        for p in map.data_points:
            self.points_dic[p.id] = p
            if p.id not in self.priors:
                self.priors[p.id] = prior_params

        # Real history is a df where every row represents a day and every coloumn a point
        self.history = pd.DataFrame([], columns=[point.id for point in map.data_points])

        # reports history saves all the reports generated
        self.reports = pd.DataFrame([], columns=['T', 'POINT_ID', 'REPORTER_ID', 'REPORTED_S', 'Veracity', 'TRUE_S'])

    def __repr__(self):
        return f"WorldManager T = {self.T}"

    def tick(self, days=1, with_show=False, with_show_values=False):
        '''
        Time moves forward - values for Datapoints change and reports are generated by reporters.
        :param days: How many days would pass
        :with_show: Show the map as it ticks
        :return:
        '''
        if with_show:
            plt.ion()

        for i in range(days):
            self.T += 1
            self.apply_calculations()
            self.update_history()
            self.generate_reports()
            self.apply_today_reports()
            # self.decay_unreported_points() #until I implement random decay there is no point in that

            if with_show:
                self.get_plot(with_show_values).draw()
                plt.title(f"T = {self.T}")
                plt.clf()
                sleep(0.6)

    def apply_calculations(self):
        ''' Applies the infection calculation to every point'''
        for point in self.map.data_points:
            new_s = self.point_calc(point, self.map.neighbors[point.id])
            point.update_s(new_s)

    def generate_reports(self):
        '''Generates reports from the reporters and updates self.reports'''
        new_reports = []
        for reporter in self.reporters:
            new_reports += reporter.report_points(self.T)
        df = pd.DataFrame(new_reports, columns=['T', 'POINT_ID', 'REPORTER_ID', 'REPORTED_S', 'Veracity', 'TRUE_S'])
        self.reports = self.reports.append(df)

    def predict_point_report(self, target_id: str, s: float, v: float, n_samples=10000):
        '''
        Updates point's prior based on a report
        :param target: Point ID for target
        :param s: report's s
        :param v:  report's veracity
        :return: points new prior params, generated by scipy
        '''

        loc = 0.99 if s == 1 else s  # to avoid values above 1
        report_dist_params = (1, loc, 0.0001)
        posterior = fit_average_posterior(self.priors[target_id], report_dist_params, self.dist_type, gamma,
                                          weights=((1 - v), v),
                                          result_dist_type=self.dist_type, n_samples=n_samples)
        if posterior[1] >= 1:
            posterior = (posterior[0], 0.98, posterior[2])
        return posterior

    def predict_point_neighbors(self, point_id, k=1000, show_as_range=False):
        '''
        Predicts a point's distribution based on its neighbors
        :param show_as_range: return the result as a range of values
        :param point_id:
        :param k:
        :return:
        '''
        target = self.points_dic[point_id]
        neighbors = self.map.neighbors[point_id] + [target]  # point is neighbor to itself

        weights = np.array(
            [self.weight_func(target.calc_distance(p), (self.T - self.last_report_times[p.id])) for p in neighbors])
        weights_sum = sum(weights)
        neighbor_predictions = np.column_stack([self.dist_type.rvs(*self.priors[p.id], size=k) for p in neighbors])
        weighted_predictions = (neighbor_predictions @ weights) / weights_sum
        new_dist = self.dist_type.fit(weighted_predictions)

        if show_as_range:
            return get_range_from_dist(self.dist_type, new_dist)

        return new_dist

    def apply_today_reports(self):
        '''
        Updates the posteriors of point's that got reported today
        :return:
        '''
        if len(self.reports) > 0:
            today_reports = self.reports[self.reports['T'] == max(self.reports['T'])]
            if len(today_reports) > 0:
                today_reports.apply(lambda row: self.update_point_prior_by_row(row), axis=1)

    def update_point_prior_by_row(self, row):
        '''
        Takes a row from the reports data frame and updates the points prior
        :param row:
        :return:
        '''
        s = row['REPORTED_S']
        v = row['Veracity']
        T = row['T']
        point_id = row['POINT_ID']
        posterior = self.predict_point_report(point_id, s, v)
        self.priors[point_id] = posterior
        self.last_report_times[point_id] = T

    def decay_unreported_points(self):
        '''
        For every points we didn't get a report, we make the points prior to look more like the hyper-prior
        '''
        t = self.T

        # hp_fit_for_assert = self.dist_type.fit(self.dist_type.rvs(**self.hyper_prior, size=50000))
        # assert (abs(hp_fit_for_assert[0] - self.hyper_prior["a"]) < 0.2 and abs(hp_fit_for_assert[2] - self.hyper_prior[
        #     "scale"]) < 0.2), "Maybe the code works with scipy.stats.gamma distribution but you provided something else"

        for p in self.map.data_points:
            point_id = p.id
            if self.last_report_times[point_id] < t:
                posterior = fit_average_posterior(self.hyper_prior, self.priors[point_id], self.dist_type,
                                                  self.dist_type,
                                                  weights=(self.prior_decay, 1 - self.prior_decay),
                                                  result_dist_type=self.dist_type)
                self.priors[point_id] = posterior

    def update_history(self):
        '''Writes the new point values to the history'''
        new_day = pd.DataFrame(np.array([[point.s] for point in self.map.data_points]).transpose(),
                               columns=[point.id for point in self.map.data_points], index=[self.T])
        self.history = self.history.append(new_day)

    def intervention(self, effect_dist, points):
        '''
        :param effect_dist: a distribution of values to draw the intervention effect from
        :param points: Datapoints on which the intervention works
        :return:
        '''
        for point in points:
            current_s = point.s
            factor = effect_dist()
            new_s = current_s + factor
            point.update_s(new_s, intervention=True)
        self.update_history()

    def random_positive_intervention(self, ratio=0.1, effect_dist=lambda: random.gauss(0.6, 0.3)):
        '''applies intervention to random points in the map. Can be used when starting the map for example'''
        n = int(len(self.map.data_points) * ratio)
        points = random.sample(self.map.data_points, n)
        self.intervention(effect_dist, points)

    def save_state(self, output_path):
        '''
        :param output_path: File to save the report at. If "none" it would just print
        :return:
        '''
        output = os.path.join(output_path, "Results")
        os.mkdir(output)
        self.reports.to_csv("reports.csv")
        self.history.to_csv("values history.csv")

    def get_plot(self, with_values=False):
        '''
        Plots current map state
        :param with_values: If true, annotates the value next to each point
        :return: returns a plot object
        '''
        values = self.history.iloc[-1].to_numpy()
        x_cors = np.array([point.x for point in self.map.data_points])
        y_cors = np.array([point.y for point in self.map.data_points])
        fig, ax = plt.subplots()
        ax.scatter(x_cors, y_cors, c=values, cmap='Reds', s=350)
        for point in self.map.data_points:
            txt = f'{point.id} s={round(point.s, 2)}' if with_values else point.id
            ax.annotate(txt, (point.x, point.y))
        return plt

    def show_real(self, with_values=False):
        '''Plots the current state of the DataPoints'''
        self.get_plot(with_values).show()

    def show_dist(self, point_id: str):
        dist_params = self.priors[point_id]
        dist_type = self.dist_type
        plot_dist(dist_type, dist_params)

    def extract_data_for_train(self, n_days: int, points_per_day = 4):
        '''
        :return:
        '''
        data = []
        for i in range(n_days):
            points_to_target = random.sample(self.map.data_points,points_per_day)
            for point in points_to_target:
                y = point.s
                neighbors = self.map.neighbors[point.id] + [point]  # point is neighbor to itself
                X = tuple([(self.priors[neighbor.id], neighbor.calc_distance(point),
                            self.T - self.last_report_times[neighbor.id]) for neighbor in neighbors])
                data.append((X,y))
        return data
