'''The WorldManager is the object that interacts with all the world objects and runs the simulation'''
import os
import random
from time import sleep

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt


class WorldManager:
    def __init__(self, map, reporters, point_calc_func, dist_type, prior_params, priors={}, dist_radius='inf',
                 time_range=5,
                 neighbors_limit=8, prior_decay=0.05):
        '''
        :param map: a Map object of the world
        :param reporters: list of Reporter objects that provide the reports
        :param point_calc_func: The function used to calculate a points value based on it's neighbors
        :param dist_type: the type of distribution for each point (e.g gamma)
        :param priors: a list of prior params for each point
        :param dist_radius: radius used to calculate Datapoint's neighbors
        :param time_range: time range used to calculate Datapoint's neighbors
        :param neighbors_limit: Max amount of neighbors a Datapoint can have
        :param prior_decay: How much a point's prior will revert back to hyper-prior every day if no report
        '''
        self.map = map
        self.reporters = reporters
        self.point_calc = point_calc_func
        self.dist_radius = dist_radius
        self.time_range = time_range
        self.neighbors_limit = neighbors_limit
        self.T = 0  # Current time
        self.dist_type = dist_type
        self.hyper_prior = prior_params
        self.prior_decay = prior_decay

        # assign prior params to any point we know nothing about
        self.priors = priors
        for p in map.data_points:
            if p.id not in self.priors:
                self.priors[p.id] = prior_params

        # Real history is a df where every row represents a day and every coloumn a point
        self.history = pd.DataFrame([], columns=[point.id for point in map.data_points])

        # reports history saves all the reports generated
        self.reports = pd.DataFrame([], columns=['T', 'POINT_ID', 'REPORTER_ID', 'REPORTED_S', 'Veracity', 'TRUE_S'])

    def __repr__(self):
        return f"WorldManager T = {self.T}"

    def tick(self, days=1, with_show=False, with_show_values=False):
        '''
        Time moves forward - values for Datapoints change and reports are generated by reporters.
        :param days: How many days would pass
        :with_show: Show the map as it ticks
        :return:
        '''
        if with_show:
            plt.ion()

        for i in range(days):
            self.apply_calculations()
            self.update_history()
            self.generate_reports()
            self.decay_unreported_points()

            if with_show:
                self.get_plot(with_show_values).draw()
                plt.title(f"T = {self.T}")
                plt.clf()
                sleep(0.6)

    def apply_calculations(self):
        ''' Applies the infection calculation to every point'''
        for point in self.map.data_points:
            new_s = self.point_calc(point, self.map.neighbors[point.id])
            point.update_s(new_s)

    def generate_reports(self):
        '''Generates reports from the reporters and updates self.reports'''
        new_reports = []
        for reporter in self.reporters:
            new_reports += reporter.report_points(self.T)
        df = pd.DataFrame(new_reports, columns=['T', 'POINT_ID', 'REPORTER_ID', 'REPORTED_S', 'Veracity', 'TRUE_S'])
        self.reports = self.reports.append(df)

    def update_point_dist_by_report(self, point_id):  # TODO make sure after every report point prior changes
        pass

    def predict_point_report(self,target, s, v, n_samples = 10000):
        '''

        :param target: A datapoint
        :param s: report's s
        :param v:  report's veracity
        :return: updates the point's prior
        '''
        prior_params = target.prior.copy()
        prior_params[
            'size'] = n_samples  # This is done so that the rvs function would be able to get the size parameter
        prior_samples = self.dist_type.rvs(**prior_params)
        report_samples = np.full(n_samples,s)

        weighted_samples = (1 - v) * prior_samples +v * report_samples
        posterior = self.dist_type.fit(weighted_samples)
        #TODO finish this

    def decay_unreported_points(self, k=10000):
        '''
        For every points we didn't get a report, we make the points prior to look more like the hyper-prior
        '''
        t = self.T
        hp_params = self.hyper_prior
        hp_params['size'] = k

        hp_fit_for_assert = self.dist_type.fit(self.dist_type.rvs(**hp_params))
        assert (abs(hp_fit_for_assert[0] - hp_params["a"]) < 0.1 and abs(hp_fit_for_assert[0] - hp_params[
            "scale"]) < 0.1), "Maybe the code works with scipy.stats.gamma distribution but you provided something else"

        for p in self.map.data_points:
            if p.last_report_t < t:
                prior_params = p.prior.copy()
                prior_params[
                    'size'] = k  # This is done so that the rvs function would be able to get the size parameter

                prior_samples = self.dist_type.rvs(**prior_params)  # returns a vector of k samples
                hp_samples = self.dist_type.rvs(**hp_params)
                weighted_samples = (1 - self.prior_decay) * prior_samples + (self.prior_decay) * hp_samples
                posterior = self.dist_type.fit(weighted_samples)

                #This only works with gamma!!
                p.prior["a"] = posterior[0]
                p.prior["scale"] = posterior[2]


    def update_history(self):
        '''Writes the new point values to the history'''
        self.T += 1
        new_day = pd.DataFrame(np.array([[point.s] for point in self.map.data_points]).transpose(),
                               columns=[point.id for point in self.map.data_points], index=[self.T])
        self.history = self.history.append(new_day)

    def intervention(self, effect_dist, points):
        '''
        :param effect_dist: a distribution of values to draw the intervention effect from
        :param points: Datapoints on which the intervention works
        :return:
        '''
        for point in points:
            current_s = point.s
            factor = effect_dist()
            new_s = current_s + factor
            point.update_s(new_s, intervention=True)
        self.update_history()

    def random_intervention(self, ratio=0.1, effect_dist=lambda: random.gauss(0.6, 0.3)):
        '''applies intervention to random points in the map. Can be used when starting the map for example'''
        n = int(len(self.map.data_points) * ratio)
        points = random.sample(self.map.data_points, n)
        self.intervention(effect_dist, points)

    def save_state(self, output_path):
        '''
        :param output_path: File to save the report at. If "none" it would just print
        :return:
        '''
        output = os.path.join(output_path, "Results")
        os.mkdir(output)
        self.reports.to_csv("reports.csv")
        self.history.to_csv("values history.csv")

    def get_plot(self, with_values=False):
        # TODO add with_values functionality
        '''
        Plots current map state
        :param with_values: If true, annotates the value next to each point
        :return: returns a plot object
        '''
        values = self.history.iloc[-1].to_numpy()
        x_cors = np.array([point.x for point in self.map.data_points])
        y_cors = np.array([point.y for point in self.map.data_points])
        plt.scatter(x_cors, y_cors, c=values, cmap='Reds', s=350)
        return plt

    def show(self, with_values=False):
        '''Plots the current state of the DataPoints'''
        self.get_plot(with_values).show()

#TODO write a function conjugate (instead of repeating code in predict_point_report and decay_time)